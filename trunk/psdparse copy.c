#include <stdio.h>#include <stdlib.h>#include "pigeneral.h"#pragma options align=mac68kstruct psd_header{	long sig;	short version;	char reserved[6];	short channels;	long rows;	long cols;	short depth;	short mode;};struct layer_info{	long top;	long left;	long bottom;	long right;	short channels;};#pragma options align=resetchar *mode_names[]={	"Bitmap", "GrayScale", "IndexedColor", "RGBColor",	"CMYKColor", "HSLColor", "HSBColor", "Multichannel",	"Duotone", "LabColor", "Gray16", "RGB48",	"Lab48", "CMYK64", "DeepMultichannel", "Duotone16"};long getlong(FILE *f){	long n;	return fread(&n,4,1,f) == 1 ? n : 0;}short getshort(FILE *f){	short n;	return fread(&n,2,1,f) == 1 ? n : 0;}void skipblock(FILE *f,char *desc){	long n = getlong(f);	if(n){		fseek(f,n,SEEK_CUR);		printf("\tskipped %s (%ld bytes)\n",desc,n);	}}void dumprow(unsigned char *b,int n){	int k,m;	m = n>40 ? 40 : n;	for(k=0;k<m;++k) 		printf("%02x",b[k]);	if(n>m) printf(" ...%d more",n-m);	putchar('\n');}void dochannel(FILE *f,int channels,int rows,int cols,int depth){	int j,n,comp,rb,ch;	long scanline;	unsigned char *rowbuf;	unsigned short *rlebuf;		comp = getshort(f);	printf("\tcompression method = %d (%s)\n",comp,comp ? "RLE" : "raw");	rb = (channels*cols*depth + 7)/8;	printf("\t(uncompressed) row bytes = %d\n",rb);	rowbuf = malloc(rb*2); /* slop for possible RLE overhead */	if(comp){		n = channels*rows;		rlebuf = malloc(n*2);		if(fread(rlebuf,2,n,f) == n){			for(ch=scanline=0;ch<channels;++ch)				for(j=0;j<rows;++j){					n = rlebuf[scanline++];					if(fread(rowbuf,1,n,f) == n){						printf("\t%d/%5d: <%5d> ",ch,j,n);						dumprow(rowbuf,n);					}else{						fprintf(stderr,"# couldn't read row!\n");						goto done;					}				}		}else 			fputs("# couldn't read RLE counts",stderr);		free(rlebuf);	}else{		for(ch=0;ch<channels;++ch)			for(j=0;j<rows;++j){				if(fread(rowbuf,1,rb,f) == rb){					printf("\t%d/%5d: ",ch,j);					dumprow(rowbuf,rb);				}else{					fprintf(stderr,"# couldn't read row!\n");					goto done;				}			}	}done:				free(rowbuf);}void dolayermaskinfo(FILE *f,struct psd_header *h){	long misclen = getlong(f),		layerlen = getlong(f),		layerstart = ftell(f);	short nlayers = getshort(f);	int i,j,channelid;	long lmilen,channellen;	struct layer_info linfo;		lmilen = getlong(f);	for(i=0;i<nlayers;++i){		fread(&linfo,sizeof(struct layer_info),1,f);		printf("\tlayer %d: (%d,%d,%d,%d), %d channels\n",			linfo.top,linfo.left,linfo.bottom,linfo.right,linfo.channels);		for(j=0;j<linfo.channels;++j){			channelid = getshort(f);			channellen = getlong(f);			printf("\tchannel %d: id=%d, %d bytes\n",channelid,channellen);			dochannel(f,1,linfo.bottom-linfo.top,linfo.right-linfo.left,h->depth);		}	}		fseek(f,layerstart+layerlen,SEEK_SET);}int main(int argc,char *argv[]){	struct psd_header h;	FILE *f;	int i;	for( i=1 ; i<argc ; ++i )		if( f = fopen(argv[i],"rb") ){			if(fread(&h,sizeof(struct psd_header),1,f) == 1 					&& h.sig == '8BPS' 					&& h.version == 1){				printf("\"%s\"\n\tchannels = %d, rows = %ld, cols = %ld, depth = %d, mode = %d (%s)\n",					argv[i], h.channels, h.rows, h.cols, h.depth,					h.mode, h.mode >= 0 && h.mode < 16 ? mode_names[h.mode] : "???");				skipblock(f,"color mode data");				skipblock(f,"image resources");				dolayermaskinfo(f,&h);				skipblock(f,"global layer mask info");								dochannel(f,h.channels,h.rows,h.cols,h.depth);			}else fprintf(stderr,"# \"%s\": couldn't read header, is not a PSD, or version is not 1!\n",argv[i]);			fclose(f);		}else fprintf(stderr,"# can't open \"%s\"!\n",argv[i]);	return EXIT_SUCCESS;}